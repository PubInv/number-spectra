<head>
  <head>
  <meta charset="UTF-8">
  <title>Number Spectra - Numberline</title>

</head>


  <script src='./samples/spectra2000x.js'></script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>


  <style>

#myCanvas {
  border:1px solid #000000;
  width: 100%;
}

#tip,#tooltiptext{
  background-color:white;
  border:1px solid blue;
  position:absolute;
  left:-600px;
  top:100px;
}

  </style>

<body>
  <canvas id="myCanvas" style="">
    </canvas>

  <p>
  <div id="tooltiptext"  width=300 height=100></div>

  <canvas id="tip" width=300 height=100></canvas>
  </body>

  <script>

var GLOBAL_TIP_CANVAS;
var GLOBAL_TIP_CTX;
var GLOBAL_DOTS = [];

function toNL(vp,A,B,N) {
  return A + vp * (B-A)/ N;
}

function toVP(nl,A,B,N) {
  return Math.round( ((nl - A) / (B - A) * N));
}

function zoom(vpl,vph,A,B,N) {
  return [
    toNL(vpl,A,B,N),
    toNL(vph,A,B,N)
  ];
}
function unzoom(vpl,vph,A,B,N) {
  // s is a scaling factor
  const s = (vph - vpl)/ N;
  const Ap = s * (vpl/N) + A;
  const Bp = s * (B - A) + Ap;
  return [Ap,Bp];
}

function unzoom_v2(vpl,vph,A,B,N) {
  return zoom(-vpl,2*N - vph,A,B,N);
}

function unzoom_old(vpl,vph,A,B,N) {
  return [
    toNL(0,A,B,vph-vpl),
    toNL(vph - vpl,A,B,vph - vpl)
  ];
}



// These are globals that
// basically represent the window and
// viewport on the number line we are creating.

var GLOBAL_NL_A = 0;
var GLOBAL_NL_B = 10;
var GLOBAL_VP_A = 0;

var GLOBAL_CANVAS = document.getElementById("myCanvas");

var GLOBAL_VP_B = GLOBAL_CANVAS.offsetWidth;
var GLOBAL_DOWN_X = 0;
var GLOBAL_DOWN_Y = 0;

function onMouseDown(e) {

  var rect = e.target.getBoundingClientRect();
  var x = e.clientX - rect.left; //x position within the element.
  var y = e.clientY - rect.top;  //y position within the element.

  GLOBAL_DOWN_X = x;
  GLOBAL_DOWN_Y = y;

  var coords = "DN X coords: " + x + ", Y coords: " + y;
  console.log(coords);

}

function onMouseUp(e) {
  var rect = e.target.getBoundingClientRect();
  var x = e.clientX - rect.left; //x position within the element.
  var y = e.clientY - rect.top;  //y position within the element.

  var coords = "UP X coords: " + x + ", Y coords: " + y;

  if (x < GLOBAL_DOWN_X) { // count this an unzoom
    [GLOBAL_NL_A,GLOBAL_NL_B] = unzoom_v2(x,GLOBAL_DOWN_X,GLOBAL_NL_A,GLOBAL_NL_B,GLOBAL_VP_B);
  } else { // count this as a zoom
    [GLOBAL_NL_A,GLOBAL_NL_B] = zoom(GLOBAL_DOWN_X,x,GLOBAL_NL_A,GLOBAL_NL_B,GLOBAL_VP_B);
  }
  console.log(coords);
  rerender();
}

GLOBAL_CANVAS.addEventListener("mouseup", onMouseUp, false);
GLOBAL_CANVAS.addEventListener("mousedown", onMouseDown, false);

// Okay, trying to do something a little
// sophisticated here...for each pixel,
// we want to compute how many points fall in
// that pixel. Then we will render the height
// of a line to represent it.
function computeSpectraHistogram(s,pl,ph) {

  // for each pixel, we want to compute
  // the number of members of the spectra inside
  // that pixel. Since the spectra is ordered,
  // This ought to be easy to compute.
  // We will consider the pixel boundary to
  // start at the low edge of pl (so that the
  // zero pixel contains zero) and go to just below
  // the next pixel.

  // first, let's find the index in the spectra
  // which is below the image of the low pixel...

  const LF = toNL(pl,GLOBAL_NL_A,GLOBAL_NL_B,GLOBAL_VP_B);
  var idx = 0;
  // now iterate the index in s so long as
  // we s[idx+1] < LF;
  while (s[idx+1].value < LF) idx++;

  // now we do the counting...
  const hist = []; // histogram mapping pixel to count
  const NUM = s.length;
  for(var i = pl; i < ph; i++) {
    const Fence = toNL(i+1,GLOBAL_NL_A,GLOBAL_NL_B,GLOBAL_VP_B);
    var cnt = 0;
    const numbers = [];
    while(idx+cnt < NUM && s[idx+cnt].value < Fence) {
      numbers.push(s[idx+cnt]);
      cnt++;
    }
    hist.push([cnt,numbers]);
    idx += cnt;
  }
  return hist;

}


// show tooltip when mouse hovers over dot
function handleMouseMove(e){
  var canvasOffset = $("#myCanvas").offset();
  var offsetX = canvasOffset.left;
  var offsetY = canvasOffset.top;
  mouseX=parseInt(e.clientX-offsetX);
  mouseY=parseInt(e.clientY-offsetY);
  console.log("pos: ", mouseX, mouseY);

  var tt = $("#tooltiptext");
  // Put your mousemove stuff here
  var hit = false;
  var strings = [];
  var X,Y;
  for (var i = 0; i < GLOBAL_DOTS.length; i++) {
    var dot = GLOBAL_DOTS[i];
    var dx = mouseX - dot.x;
    var dy = mouseY - dot.ymin
    console.log("x,y, ymin, ymax",mouseX,mouseY,dot.ymin,dot.ymax);
    if ((mouseX == dot.x) && (dot.ymin <= mouseY) && (mouseY <= dot.ymax)) {
      // GLOBAL_TIP_CANVAS.style.left = (dot.x) + "px";
      X = dot.x;
      Y = dot.ymin - 40;
//      GLOBAL_TIP_CANVAS.style.top = (dot.ymin - 40) + "px";
      for(var j = 0; j < dot.numbers.length; j++) {
        var n = dot.numbers[j];
        strings.push("v: " + n.value + " e: " + n.expression_text);
      }
      hit = true;
    }
  }
  if (!hit) { tt.css('left',"-600px"); }
  else {
    const ns = strings.length;
    const lh = 15;
    // GLOBAL_TIP_CANVAS.style.width = 400;
    // GLOBAL_TIP_CANVAS.style.height = (ns+2) * lh;
    // GLOBAL_TIP_CTX.clearRect(0,
    //                          0,
    //                          GLOBAL_TIP_CANVAS.width,
    //                          GLOBAL_TIP_CANVAS.height);
    // GLOBAL_TIP_CTX.font = '15px';
    // var y = 15;
    // for (var k = 0; k < ns; k++) {
    //   GLOBAL_TIP_CTX.fillText(
    //     strings[k],
    //     5, y + k * 15);
    // }
    tt.css('height',(ns+2) * lh + 'px');
    tt.css('top',Y);
    tt.css('left',X);
    tt.html('<div>'+ strings.join(",<br>\n")+ '<\div>');
    console.log(tt.text());
  }

}

function drawLines(hist,canvas,pl,ph) {

  const H = canvas.height;
  const M = H/2;
//  const mv = Math.max(...hist);
  const mv = hist.reduce(
        (accumulator, currentValue) => {
            return Math.max(currentValue[0], accumulator);
        },  Number.MIN_VALUE
  );
  const dots = [];
  for(var i = pl; i < ph; i++) {
    const v = hist[i][0];
    const d = (v/mv)* M/2;
    // Now we want to render a line line of height
    // v....
    if (v > 0) {
      var ctx = canvas.getContext("2d");
      ctx.beginPath();
      ctx.moveTo(i,M);

      ctx.lineTo(i,M + -d);
      ctx.stroke();

      dots.push({
        x: i,
        ymin: M + -d,
        ymax: M,
        numbers: hist[i][1]
      });
    }
  }
  GLOBAL_DOTS = dots;
}

// This is an attempt to draw a nice set of tick
// marks in on the canvas
function drawNumberline(hist,canvas,pl,ph,A,B) {

  const H = canvas.height;
  var ctx = canvas.getContext("2d");
  const M = H/2;
  ctx.beginPath();
  ctx.moveTo(pl, M);
  ctx.lineTo(ph, M);
  ctx.stroke();

  const N = ph;


  // First, let us compute the decimal division
  // needed to make minor tick marks no more
  // than 30 pixels apart...
  const MAX_PIXELS_PER_MINOR_TICK = 200;

  // We want at least this many ticks...
  const MIN_TICKS = (ph - pl) / MAX_PIXELS_PER_MINOR_TICK;
  const d = B-A;
  const tick_exp = Math.floor(Math.log10(d/MIN_TICKS));
  const tick = Math.pow(10,tick_exp);
  console.log("TICK",tick,tick_exp);

  // Now divide A by the tick, and take the floor...
  const first_tick = Math.floor(A/tick)*tick;
  const last_tick = Math.ceil(B/tick)*tick;
  for(var t = first_tick; t < last_tick; t += tick) {
    const string = ""+t.toFixed(Math.max(-tick_exp,0));

    var L;
    if (string.substr(-1) == '0') {
      L = M/2;
      ctx.strokeStyle = "#000000";
    } else if (string.substr(-1) == '5') {
      L = M/3;
      ctx.strokeStyle = "#00aa00";
    } else {
      L = M/4;
      ctx.strokeStyle = "#FF0000";
    }

    ctx.font = "10px Arial";
    const horiz = toVP(t,A,B,N);
    ctx.fillText(string, horiz, M + L+20);
    ctx.beginPath();
    ctx.moveTo(horiz, M - L);
    ctx.lineTo(horiz, M + L);
    ctx.stroke();
  }
}

function renderSpectra(s,canvas) {
  const pl = 0;
  const ph =  GLOBAL_CANVAS.offsetWidth; // really this should be the canvas width
  const hist = computeSpectraHistogram(s,pl,ph);
  drawLines(hist,canvas,pl,ph);
  drawNumberline(hist,canvas,pl,ph,GLOBAL_NL_A,GLOBAL_NL_B);
}

function rerender() {

  GLOBAL_CANVAS.width  = GLOBAL_CANVAS.offsetWidth;
  GLOBAL_CANVAS.height = GLOBAL_CANVAS.offsetHeight;
  var ctx = GLOBAL_CANVAS.getContext("2d");
  ctx.clearRect(0, 0,GLOBAL_CANVAS.offsetWidth , GLOBAL_CANVAS.offsetHeight);
  renderSpectra(SPECTRA0,GLOBAL_CANVAS);

}

    // request mousemove events
$(document).ready(function()  {

    GLOBAL_TIP_CANVAS = document.getElementById("tip");
    GLOBAL_TIP_CTX = GLOBAL_TIP_CANVAS.getContext("2d");


  $("#myCanvas").mousemove(function(e){handleMouseMove(e);});

  rerender();
});

</script>
